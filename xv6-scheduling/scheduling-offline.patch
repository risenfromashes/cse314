diff --git a/Makefile b/Makefile
index 39a99d7..3accb48 100644
--- a/Makefile
+++ b/Makefile
@@ -28,7 +28,8 @@ OBJS = \
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
-  $K/virtio_disk.o
+  $K/virtio_disk.o \
+  $K/random.o
 
 # riscv64-unknown-elf- or riscv64-linux-gnu-
 # perhaps in /opt/riscv/bin
@@ -132,6 +133,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_test\
+	$U/_dummyproc\
+	$U/_testprocinfo\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
@@ -153,7 +157,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 3
+CPUS := 1
 endif
 
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
diff --git a/compile_flags.txt b/compile_flags.txt
new file mode 100644
index 0000000..60a4aad
--- /dev/null
+++ b/compile_flags.txt
@@ -0,0 +1 @@
+-I.
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..9ec984e 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -185,5 +185,9 @@ void            virtio_disk_init(void);
 void            virtio_disk_rw(struct buf *, int);
 void            virtio_disk_intr(void);
 
+// random.c
+void            seed(uint64);
+uint64          random();
+
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/kernel/param.h b/kernel/param.h
index 6624bff..73549e2 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -1,13 +1,17 @@
-#define NPROC        64  // maximum number of processes
-#define NCPU          8  // maximum number of CPUs
-#define NOFILE       16  // open files per process
-#define NFILE       100  // open files per system
-#define NINODE       50  // maximum number of active i-nodes
-#define NDEV         10  // maximum major device number
-#define ROOTDEV       1  // device number of file system root disk
-#define MAXARG       32  // max exec arguments
-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       2000  // size of file system in blocks
-#define MAXPATH      128   // maximum file path name
+#define NPROC                64               // maximum number of processes
+#define NCPU                 8                // maximum number of CPUs
+#define NOFILE               16               // open files per process
+#define NFILE                100              // open files per system
+#define NINODE               50               // maximum number of active i-nodes
+#define NDEV                 10               // maximum major device number
+#define ROOTDEV              1                // device number of file system root disk
+#define MAXARG               32               // max exec arguments
+#define MAXOPBLOCKS          10               // max # of blocks any FS op writes
+#define LOGSIZE              (MAXOPBLOCKS*3)  // max data blocks in on-disk log
+#define NBUF                 (MAXOPBLOCKS*3)  // size of disk block cache
+#define FSSIZE               2000             // size of file system in blocks
+#define MAXPATH              128              // maximum file path name
+#define DEFAULT_TICKET_COUNT 10               // default ticket count for each process
+#define TIME_LIMIT_1         1                // queue 1 allocated time slice
+#define TIME_LIMIT_2         2                // queue 1 allocated time slice
+#define BOOST_INTERVAL       64               // interval between MLFQ boosting
\ No newline at end of file
diff --git a/kernel/pqueue.c b/kernel/pqueue.c
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/kernel/pqueue.c
@@ -0,0 +1 @@
+
diff --git a/kernel/pqueue.h b/kernel/pqueue.h
new file mode 100644
index 0000000..0464c4e
--- /dev/null
+++ b/kernel/pqueue.h
@@ -0,0 +1,26 @@
+#ifndef __PROC_QUEUE_H__
+#define __PROC_QUEUE_H__
+
+struct proc;
+
+enum pqueue_strategy {
+  PQUEUE_LOTTERY = 0,
+  PQUEUE_ROUND_ROBIN = 1
+};
+
+struct pnode {
+  struct proc *p;
+  int tickets;
+};
+
+struct pqueue {
+  struct pnode[NPROC];
+  int tail;
+  enum pqueue_strategy strategy;
+};
+
+struct pnode *pqueue_push(struct pqueue* q, struct proc *proc);
+struct pnode *pqueue_pop(struct pqueue* q);
+int pqueue_length();
+
+#endif
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..b1adb20 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -91,6 +91,10 @@ struct proc {
   int killed;                  // If non-zero, have been killed
   int xstate;                  // Exit status to be returned to parent's wait
   int pid;                     // Process ID
+  uint64 allocated_tickets;    // tickets to be allocated to this process
+  uint64 current_tickets;      // tickets currently left
+  int queue;                   // index of the queue in use
+  int time_slices;             // number of time slices used since scheduling
 
   // wait_lock must be held when using this:
   struct proc *parent;         // Parent process
diff --git a/kernel/random.c b/kernel/random.c
new file mode 100644
index 0000000..42ed3e7
--- /dev/null
+++ b/kernel/random.c
@@ -0,0 +1,12 @@
+#include "kernel/types.h"
+
+uint64 _seed = 1000;
+const uint64 A = 1103515245;
+const uint64 C = 12345;
+
+void seed(uint64 seed) { _seed = seed; }
+
+uint64 random() {
+  _seed = (A * _seed + C) & ((1u << 31) - 1);
+  return _seed;
+}
\ No newline at end of file
